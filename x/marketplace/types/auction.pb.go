// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bitsong/marketplace/auction.proto

package types

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

/// Define valid auction state transitions.
type AuctionState int32

const (
	AuctionState_Empty   AuctionState = 0
	AuctionState_Created AuctionState = 1
	AuctionState_Started AuctionState = 2
	AuctionState_Ended   AuctionState = 3
)

var AuctionState_name = map[int32]string{
	0: "EMPTY",
	1: "CREATED",
	2: "STARTED",
	3: "ENDED",
}

var AuctionState_value = map[string]int32{
	"EMPTY":   0,
	"CREATED": 1,
	"STARTED": 2,
	"ENDED":   3,
}

func (x AuctionState) String() string {
	return proto.EnumName(AuctionState_name, int32(x))
}

func (AuctionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{0}
}

type AuctionPrizeType int32

const (
	// Transfer ownership of only nft without metadata
	AuctionPrizeType_NftOnlyTransfer AuctionPrizeType = 0
	// Transfer ownership of both nft and metadata
	AuctionPrizeType_FullRightsTransfer AuctionPrizeType = 1
)

var AuctionPrizeType_name = map[int32]string{
	0: "NFT_ONLY_TRANSFER",
	1: "FULL_RIGHTS_TRANSFER",
}

var AuctionPrizeType_value = map[string]int32{
	"NFT_ONLY_TRANSFER":    0,
	"FULL_RIGHTS_TRANSFER": 1,
}

func (x AuctionPrizeType) String() string {
	return proto.EnumName(AuctionPrizeType_name, int32(x))
}

func (AuctionPrizeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{1}
}

type Auction struct {
	// unique identifier of the auction
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// authority with permission to modify this auction.
	Authority string `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
	// NFT being used to bid
	NftId uint64 `protobuf:"varint,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	// Describes transfering nft ownership only or metadata ownership as well
	PrizeType AuctionPrizeType `protobuf:"varint,4,opt,name=prize_type,json=prizeType,proto3,enum=bitsong.marketplace.v1beta1.AuctionPrizeType" json:"prize_type,omitempty"`
	// Duration of the auction
	Duration *time.Duration `protobuf:"bytes,5,opt,name=duration,proto3,stdduration" json:"duration,omitempty"`
	// Denom to be used on bids
	BidDenom string `protobuf:"bytes,6,opt,name=bid_denom,json=bidDenom,proto3" json:"bid_denom,omitempty"`
	// Minimum price for any bid to meet.
	PriceFloor uint64 `protobuf:"varint,7,opt,name=price_floor,json=priceFloor,proto3" json:"price_floor,omitempty"`
	// Instant sale price
	InstantSalePrice uint64 `protobuf:"varint,8,opt,name=instant_sale_price,json=instantSalePrice,proto3" json:"instant_sale_price,omitempty"`
	// Tick size - how much higher the next bid must be to beat out the previous bid.
	TickSize uint64 `protobuf:"varint,9,opt,name=tick_size,json=tickSize,proto3" json:"tick_size,omitempty"`
	// The state the auction is in, whether it has started or ended.
	State AuctionState `protobuf:"varint,10,opt,name=state,proto3,enum=bitsong.marketplace.v1beta1.AuctionState" json:"state,omitempty"`
	// The amount of bid put last time
	LastBidAmount uint64 `protobuf:"varint,11,opt,name=last_bid_amount,json=lastBidAmount,proto3" json:"last_bid_amount,omitempty"`
	// The time the last bid was placed, used to keep track of auction timing.
	LastBid *time.Time `protobuf:"bytes,12,opt,name=last_bid,json=lastBid,proto3,stdtime" json:"last_bid,omitempty"`
	// Slot time the auction was officially ended by.
	EndedAt *time.Time `protobuf:"bytes,13,opt,name=ended_at,json=endedAt,proto3,stdtime" json:"ended_at,omitempty"`
	// End time is the cut-off point that the auction is forced to end by.
	EndAuctionAt *time.Time `protobuf:"bytes,14,opt,name=end_auction_at,json=endAuctionAt,proto3,stdtime" json:"end_auction_at,omitempty"`
	// Ticked to true when a prize is claimed by person who won it
	Claimed bool `protobuf:"varint,15,opt,name=claimed,proto3" json:"claimed,omitempty"`
}

func (m *Auction) Reset()         { *m = Auction{} }
func (m *Auction) String() string { return proto.CompactTextString(m) }
func (*Auction) ProtoMessage()    {}
func (*Auction) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{0}
}
func (m *Auction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Auction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Auction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Auction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Auction.Merge(m, src)
}
func (m *Auction) XXX_Size() int {
	return m.Size()
}
func (m *Auction) XXX_DiscardUnknown() {
	xxx_messageInfo_Auction.DiscardUnknown(m)
}

var xxx_messageInfo_Auction proto.InternalMessageInfo

func (m *Auction) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Auction) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *Auction) GetNftId() uint64 {
	if m != nil {
		return m.NftId
	}
	return 0
}

func (m *Auction) GetPrizeType() AuctionPrizeType {
	if m != nil {
		return m.PrizeType
	}
	return AuctionPrizeType_NftOnlyTransfer
}

func (m *Auction) GetDuration() *time.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *Auction) GetBidDenom() string {
	if m != nil {
		return m.BidDenom
	}
	return ""
}

func (m *Auction) GetPriceFloor() uint64 {
	if m != nil {
		return m.PriceFloor
	}
	return 0
}

func (m *Auction) GetInstantSalePrice() uint64 {
	if m != nil {
		return m.InstantSalePrice
	}
	return 0
}

func (m *Auction) GetTickSize() uint64 {
	if m != nil {
		return m.TickSize
	}
	return 0
}

func (m *Auction) GetState() AuctionState {
	if m != nil {
		return m.State
	}
	return AuctionState_Empty
}

func (m *Auction) GetLastBidAmount() uint64 {
	if m != nil {
		return m.LastBidAmount
	}
	return 0
}

func (m *Auction) GetLastBid() *time.Time {
	if m != nil {
		return m.LastBid
	}
	return nil
}

func (m *Auction) GetEndedAt() *time.Time {
	if m != nil {
		return m.EndedAt
	}
	return nil
}

func (m *Auction) GetEndAuctionAt() *time.Time {
	if m != nil {
		return m.EndAuctionAt
	}
	return nil
}

func (m *Auction) GetClaimed() bool {
	if m != nil {
		return m.Claimed
	}
	return false
}

// Bids associate a bidding key with an amount bid.
type Bid struct {
	Bidder    string `protobuf:"bytes,1,opt,name=bidder,proto3" json:"bidder,omitempty"`
	AuctionId uint64 `protobuf:"varint,2,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
	Amount    uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *Bid) Reset()         { *m = Bid{} }
func (m *Bid) String() string { return proto.CompactTextString(m) }
func (*Bid) ProtoMessage()    {}
func (*Bid) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{1}
}
func (m *Bid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bid.Merge(m, src)
}
func (m *Bid) XXX_Size() int {
	return m.Size()
}
func (m *Bid) XXX_DiscardUnknown() {
	xxx_messageInfo_Bid.DiscardUnknown(m)
}

var xxx_messageInfo_Bid proto.InternalMessageInfo

func (m *Bid) GetBidder() string {
	if m != nil {
		return m.Bidder
	}
	return ""
}

func (m *Bid) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *Bid) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

/// Models a set of metadata for a bidder, meant to be stored in a PDA. This allows looking up
/// information about a bidder regardless of if they have won, lost or cancelled.
type BidderMetadata struct {
	// Relationship with the bidder who's metadata this covers.
	Bidder string `protobuf:"bytes,1,opt,name=bidder,proto3" json:"bidder,omitempty"`
	// Relationship with the auction this bid was placed on.
	LastAuctionId string `protobuf:"bytes,2,opt,name=last_auction_id,json=lastAuctionId,proto3" json:"last_auction_id,omitempty"`
	// Amount that the user bid.
	LastBid uint64 `protobuf:"varint,3,opt,name=last_bid,json=lastBid,proto3" json:"last_bid,omitempty"`
	// Tracks the last time this user bid.
	LastBidTimestamp *time.Time `protobuf:"bytes,4,opt,name=last_bid_timestamp,json=lastBidTimestamp,proto3,stdtime" json:"last_bid_timestamp,omitempty"`
	// Whether the last bid the user made was cancelled. This should also be enough to know if the
	// user is a winner, as if cancelled it implies previous bids were also cancelled.
	LastBidCancelled bool `protobuf:"varint,5,opt,name=last_bid_cancelled,json=lastBidCancelled,proto3" json:"last_bid_cancelled,omitempty"`
}

func (m *BidderMetadata) Reset()         { *m = BidderMetadata{} }
func (m *BidderMetadata) String() string { return proto.CompactTextString(m) }
func (*BidderMetadata) ProtoMessage()    {}
func (*BidderMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{2}
}
func (m *BidderMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BidderMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BidderMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BidderMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BidderMetadata.Merge(m, src)
}
func (m *BidderMetadata) XXX_Size() int {
	return m.Size()
}
func (m *BidderMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_BidderMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_BidderMetadata proto.InternalMessageInfo

func (m *BidderMetadata) GetBidder() string {
	if m != nil {
		return m.Bidder
	}
	return ""
}

func (m *BidderMetadata) GetLastAuctionId() string {
	if m != nil {
		return m.LastAuctionId
	}
	return ""
}

func (m *BidderMetadata) GetLastBid() uint64 {
	if m != nil {
		return m.LastBid
	}
	return 0
}

func (m *BidderMetadata) GetLastBidTimestamp() *time.Time {
	if m != nil {
		return m.LastBidTimestamp
	}
	return nil
}

func (m *BidderMetadata) GetLastBidCancelled() bool {
	if m != nil {
		return m.LastBidCancelled
	}
	return false
}

// Params defines marketplace module's parameters
type Params struct {
	IssuePrice types.Coin `protobuf:"bytes,1,opt,name=issue_price,json=issuePrice,proto3" json:"issue_price" yaml:"issue_price"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{3}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetIssuePrice() types.Coin {
	if m != nil {
		return m.IssuePrice
	}
	return types.Coin{}
}

type EventCreateAuction struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	AuctionId uint64 `protobuf:"varint,2,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
}

func (m *EventCreateAuction) Reset()         { *m = EventCreateAuction{} }
func (m *EventCreateAuction) String() string { return proto.CompactTextString(m) }
func (*EventCreateAuction) ProtoMessage()    {}
func (*EventCreateAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{4}
}
func (m *EventCreateAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCreateAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCreateAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCreateAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCreateAuction.Merge(m, src)
}
func (m *EventCreateAuction) XXX_Size() int {
	return m.Size()
}
func (m *EventCreateAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCreateAuction.DiscardUnknown(m)
}

var xxx_messageInfo_EventCreateAuction proto.InternalMessageInfo

func (m *EventCreateAuction) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *EventCreateAuction) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

type EventSetAuctionAuthority struct {
	AuctionId uint64 `protobuf:"varint,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
	Authority string `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
}

func (m *EventSetAuctionAuthority) Reset()         { *m = EventSetAuctionAuthority{} }
func (m *EventSetAuctionAuthority) String() string { return proto.CompactTextString(m) }
func (*EventSetAuctionAuthority) ProtoMessage()    {}
func (*EventSetAuctionAuthority) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{5}
}
func (m *EventSetAuctionAuthority) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetAuctionAuthority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetAuctionAuthority.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetAuctionAuthority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetAuctionAuthority.Merge(m, src)
}
func (m *EventSetAuctionAuthority) XXX_Size() int {
	return m.Size()
}
func (m *EventSetAuctionAuthority) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetAuctionAuthority.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetAuctionAuthority proto.InternalMessageInfo

func (m *EventSetAuctionAuthority) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *EventSetAuctionAuthority) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

type EventStartAuction struct {
	AuctionId uint64 `protobuf:"varint,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
}

func (m *EventStartAuction) Reset()         { *m = EventStartAuction{} }
func (m *EventStartAuction) String() string { return proto.CompactTextString(m) }
func (*EventStartAuction) ProtoMessage()    {}
func (*EventStartAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{6}
}
func (m *EventStartAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventStartAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventStartAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventStartAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventStartAuction.Merge(m, src)
}
func (m *EventStartAuction) XXX_Size() int {
	return m.Size()
}
func (m *EventStartAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_EventStartAuction.DiscardUnknown(m)
}

var xxx_messageInfo_EventStartAuction proto.InternalMessageInfo

func (m *EventStartAuction) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

type EventEndAuction struct {
	AuctionId uint64 `protobuf:"varint,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
}

func (m *EventEndAuction) Reset()         { *m = EventEndAuction{} }
func (m *EventEndAuction) String() string { return proto.CompactTextString(m) }
func (*EventEndAuction) ProtoMessage()    {}
func (*EventEndAuction) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{7}
}
func (m *EventEndAuction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEndAuction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEndAuction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEndAuction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEndAuction.Merge(m, src)
}
func (m *EventEndAuction) XXX_Size() int {
	return m.Size()
}
func (m *EventEndAuction) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEndAuction.DiscardUnknown(m)
}

var xxx_messageInfo_EventEndAuction proto.InternalMessageInfo

func (m *EventEndAuction) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

type EventPlaceBid struct {
	Bidder    string `protobuf:"bytes,1,opt,name=bidder,proto3" json:"bidder,omitempty"`
	AuctionId uint64 `protobuf:"varint,2,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
}

func (m *EventPlaceBid) Reset()         { *m = EventPlaceBid{} }
func (m *EventPlaceBid) String() string { return proto.CompactTextString(m) }
func (*EventPlaceBid) ProtoMessage()    {}
func (*EventPlaceBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{8}
}
func (m *EventPlaceBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPlaceBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPlaceBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPlaceBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPlaceBid.Merge(m, src)
}
func (m *EventPlaceBid) XXX_Size() int {
	return m.Size()
}
func (m *EventPlaceBid) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPlaceBid.DiscardUnknown(m)
}

var xxx_messageInfo_EventPlaceBid proto.InternalMessageInfo

func (m *EventPlaceBid) GetBidder() string {
	if m != nil {
		return m.Bidder
	}
	return ""
}

func (m *EventPlaceBid) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

type EventCancelBid struct {
	Bidder    string `protobuf:"bytes,1,opt,name=bidder,proto3" json:"bidder,omitempty"`
	AuctionId uint64 `protobuf:"varint,2,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
}

func (m *EventCancelBid) Reset()         { *m = EventCancelBid{} }
func (m *EventCancelBid) String() string { return proto.CompactTextString(m) }
func (*EventCancelBid) ProtoMessage()    {}
func (*EventCancelBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{9}
}
func (m *EventCancelBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCancelBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCancelBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCancelBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCancelBid.Merge(m, src)
}
func (m *EventCancelBid) XXX_Size() int {
	return m.Size()
}
func (m *EventCancelBid) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCancelBid.DiscardUnknown(m)
}

var xxx_messageInfo_EventCancelBid proto.InternalMessageInfo

func (m *EventCancelBid) GetBidder() string {
	if m != nil {
		return m.Bidder
	}
	return ""
}

func (m *EventCancelBid) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

type EventClaimBid struct {
	Bidder    string `protobuf:"bytes,1,opt,name=bidder,proto3" json:"bidder,omitempty"`
	AuctionId uint64 `protobuf:"varint,2,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty"`
}

func (m *EventClaimBid) Reset()         { *m = EventClaimBid{} }
func (m *EventClaimBid) String() string { return proto.CompactTextString(m) }
func (*EventClaimBid) ProtoMessage()    {}
func (*EventClaimBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_a6afa43dc1392bc5, []int{10}
}
func (m *EventClaimBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventClaimBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventClaimBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventClaimBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventClaimBid.Merge(m, src)
}
func (m *EventClaimBid) XXX_Size() int {
	return m.Size()
}
func (m *EventClaimBid) XXX_DiscardUnknown() {
	xxx_messageInfo_EventClaimBid.DiscardUnknown(m)
}

var xxx_messageInfo_EventClaimBid proto.InternalMessageInfo

func (m *EventClaimBid) GetBidder() string {
	if m != nil {
		return m.Bidder
	}
	return ""
}

func (m *EventClaimBid) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func init() {
	proto.RegisterEnum("bitsong.marketplace.v1beta1.AuctionState", AuctionState_name, AuctionState_value)
	proto.RegisterEnum("bitsong.marketplace.v1beta1.AuctionPrizeType", AuctionPrizeType_name, AuctionPrizeType_value)
	proto.RegisterType((*Auction)(nil), "bitsong.marketplace.v1beta1.Auction")
	proto.RegisterType((*Bid)(nil), "bitsong.marketplace.v1beta1.Bid")
	proto.RegisterType((*BidderMetadata)(nil), "bitsong.marketplace.v1beta1.BidderMetadata")
	proto.RegisterType((*Params)(nil), "bitsong.marketplace.v1beta1.Params")
	proto.RegisterType((*EventCreateAuction)(nil), "bitsong.marketplace.v1beta1.EventCreateAuction")
	proto.RegisterType((*EventSetAuctionAuthority)(nil), "bitsong.marketplace.v1beta1.EventSetAuctionAuthority")
	proto.RegisterType((*EventStartAuction)(nil), "bitsong.marketplace.v1beta1.EventStartAuction")
	proto.RegisterType((*EventEndAuction)(nil), "bitsong.marketplace.v1beta1.EventEndAuction")
	proto.RegisterType((*EventPlaceBid)(nil), "bitsong.marketplace.v1beta1.EventPlaceBid")
	proto.RegisterType((*EventCancelBid)(nil), "bitsong.marketplace.v1beta1.EventCancelBid")
	proto.RegisterType((*EventClaimBid)(nil), "bitsong.marketplace.v1beta1.EventClaimBid")
}

func init() { proto.RegisterFile("bitsong/marketplace/auction.proto", fileDescriptor_a6afa43dc1392bc5) }

var fileDescriptor_a6afa43dc1392bc5 = []byte{
	// 975 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x4d, 0x6f, 0xdb, 0x36,
	0x18, 0xb6, 0xd2, 0x38, 0xb6, 0xe9, 0xc4, 0x71, 0xb9, 0xac, 0x50, 0xdd, 0xcd, 0xf6, 0x74, 0x18,
	0xbc, 0x60, 0x95, 0xda, 0xec, 0xb4, 0xee, 0x30, 0xf8, 0xb3, 0x0b, 0x90, 0xb8, 0x86, 0xac, 0x6d,
	0xe8, 0x2e, 0x02, 0x2d, 0xd2, 0x0e, 0x57, 0x49, 0x14, 0x24, 0xba, 0x98, 0xf3, 0x13, 0x72, 0xea,
	0xb1, 0x97, 0x00, 0xbd, 0xed, 0xaf, 0xf4, 0xd8, 0xe3, 0x4e, 0xdd, 0x90, 0x5c, 0xb6, 0xeb, 0x7e,
	0xc1, 0x40, 0x4a, 0x54, 0xd2, 0x0c, 0x6b, 0x82, 0xee, 0x46, 0xbe, 0x7c, 0x9f, 0xe7, 0x25, 0x9f,
	0xf7, 0x43, 0x02, 0x9f, 0xcd, 0x28, 0x4f, 0x58, 0xb8, 0xb0, 0x02, 0x14, 0x3f, 0x23, 0x3c, 0xf2,
	0x91, 0x47, 0x2c, 0xb4, 0xf4, 0x38, 0x65, 0xa1, 0x19, 0xc5, 0x8c, 0x33, 0x78, 0x2f, 0x73, 0x31,
	0x2f, 0xb9, 0x98, 0xcf, 0x1f, 0xce, 0x08, 0x47, 0x0f, 0x1b, 0xad, 0x05, 0x63, 0x0b, 0x9f, 0x58,
	0xd2, 0x75, 0xb6, 0x9c, 0x5b, 0x9c, 0x06, 0x24, 0xe1, 0x28, 0x88, 0x52, 0x74, 0xa3, 0x79, 0xd5,
	0x01, 0x2f, 0x63, 0x74, 0xc1, 0xde, 0xd8, 0x59, 0xb0, 0x05, 0x93, 0x4b, 0x4b, 0xac, 0x14, 0xca,
	0x63, 0x49, 0xc0, 0x12, 0x6b, 0x86, 0x12, 0x62, 0x65, 0xb1, 0x2c, 0x8f, 0xd1, 0x0c, 0x65, 0xfc,
	0x5a, 0x04, 0xa5, 0x6e, 0x7a, 0x4b, 0x58, 0x03, 0x6b, 0x14, 0xeb, 0x5a, 0x5b, 0xeb, 0xac, 0xdb,
	0x6b, 0x14, 0xc3, 0x4f, 0x40, 0x05, 0x2d, 0xf9, 0x11, 0x8b, 0x29, 0x5f, 0xe9, 0x6b, 0x6d, 0xad,
	0x53, 0xb1, 0x2f, 0x0c, 0xf0, 0x63, 0xb0, 0x11, 0xce, 0xb9, 0x4b, 0xb1, 0x7e, 0x4b, 0x22, 0x8a,
	0xe1, 0x9c, 0xef, 0x63, 0x78, 0x00, 0x40, 0x14, 0xd3, 0x63, 0xe2, 0xf2, 0x55, 0x44, 0xf4, 0xf5,
	0xb6, 0xd6, 0xa9, 0xed, 0xdd, 0x37, 0xdf, 0xf3, 0x72, 0x33, 0x0b, 0x3f, 0x11, 0x28, 0x67, 0x15,
	0x11, 0xbb, 0x12, 0xa9, 0x25, 0xfc, 0x06, 0x94, 0xd5, 0x33, 0xf5, 0x62, 0x5b, 0xeb, 0x54, 0xf7,
	0xee, 0x9a, 0xa9, 0x0e, 0xa6, 0xd2, 0xc1, 0x1c, 0x64, 0x0e, 0xbd, 0xf5, 0x97, 0xbf, 0xb7, 0x34,
	0x3b, 0x07, 0xc0, 0x7b, 0xa0, 0x32, 0xa3, 0xd8, 0xc5, 0x24, 0x64, 0x81, 0xbe, 0x21, 0xef, 0x5f,
	0x9e, 0x51, 0x3c, 0x10, 0x7b, 0xd8, 0x02, 0xd5, 0x28, 0xa6, 0x1e, 0x71, 0xe7, 0x3e, 0x63, 0xb1,
	0x5e, 0x92, 0x6f, 0x00, 0xd2, 0x34, 0x12, 0x16, 0xf8, 0x25, 0x80, 0x34, 0x4c, 0x38, 0x0a, 0xb9,
	0x9b, 0x20, 0x9f, 0xb8, 0xf2, 0x48, 0x2f, 0x4b, 0xbf, 0x7a, 0x76, 0x32, 0x45, 0x3e, 0x99, 0x08,
	0xbb, 0x88, 0xc5, 0xa9, 0xf7, 0xcc, 0x4d, 0xe8, 0x31, 0xd1, 0x2b, 0xd2, 0xa9, 0x2c, 0x0c, 0x53,
	0x7a, 0x4c, 0xe0, 0xb7, 0xa0, 0x98, 0x70, 0xc4, 0x89, 0x0e, 0xa4, 0x1c, 0x5f, 0xdc, 0x44, 0x8e,
	0xa9, 0x00, 0xd8, 0x29, 0x0e, 0x7e, 0x0e, 0xb6, 0x7d, 0x94, 0x70, 0x57, 0x3c, 0x07, 0x05, 0x6c,
	0x19, 0x72, 0xbd, 0x2a, 0x63, 0x6c, 0x09, 0x73, 0x8f, 0xe2, 0xae, 0x34, 0x0a, 0xb9, 0x94, 0x9f,
	0xbe, 0x29, 0xe5, 0x6a, 0xfc, 0x4b, 0x2e, 0x47, 0xd5, 0x55, 0x6f, 0xfd, 0x85, 0xd0, 0xab, 0x94,
	0x51, 0x08, 0x30, 0x09, 0x31, 0xc1, 0x2e, 0xe2, 0xfa, 0xd6, 0x4d, 0xc1, 0x12, 0xd1, 0xe5, 0x70,
	0x04, 0x6a, 0x24, 0xc4, 0x6e, 0x56, 0xf0, 0x82, 0xa2, 0x76, 0x43, 0x8a, 0x4d, 0x12, 0xe2, 0xec,
	0xcd, 0x5d, 0x0e, 0x75, 0x50, 0xf2, 0x7c, 0x44, 0x03, 0x82, 0xf5, 0xed, 0xb6, 0xd6, 0x29, 0xdb,
	0x6a, 0x6b, 0x38, 0xe0, 0x96, 0xb8, 0xe5, 0x1d, 0xb0, 0x31, 0xa3, 0x18, 0x93, 0x58, 0x16, 0x6a,
	0xc5, 0xce, 0x76, 0xf0, 0x53, 0x00, 0x54, 0x70, 0x8a, 0x65, 0xb5, 0xae, 0x8b, 0x6a, 0x95, 0x96,
	0x7d, 0x09, 0xcb, 0x84, 0x4b, 0xab, 0x35, 0xdb, 0x19, 0x7f, 0x69, 0xa0, 0xd6, 0x93, 0x0c, 0x87,
	0x84, 0x23, 0x8c, 0x38, 0xfa, 0xcf, 0x08, 0x2a, 0x09, 0x57, 0xc2, 0x54, 0xd2, 0x24, 0x74, 0xf3,
	0x50, 0x77, 0x2f, 0x25, 0x21, 0x0d, 0x96, 0x4b, 0x3c, 0x06, 0x30, 0xcf, 0x63, 0xde, 0xdf, 0xb2,
	0x49, 0x6e, 0xa2, 0x54, 0x3d, 0xa3, 0xc9, 0xed, 0xa2, 0x46, 0x73, 0x3e, 0x0f, 0x85, 0x1e, 0xf1,
	0x7d, 0x82, 0x65, 0xa3, 0x94, 0x73, 0xef, 0xbe, 0xb2, 0x1b, 0x3f, 0x83, 0x8d, 0x09, 0x8a, 0x51,
	0x90, 0xc0, 0x1f, 0x40, 0x95, 0x26, 0xc9, 0x52, 0x15, 0xb5, 0x96, 0x75, 0x56, 0x3a, 0x2b, 0x4c,
	0x31, 0x2b, 0xf2, 0x72, 0xec, 0x33, 0x1a, 0xf6, 0x1a, 0xaf, 0xdf, 0xb6, 0x0a, 0x7f, 0xbf, 0x6d,
	0xc1, 0x15, 0x0a, 0xfc, 0x47, 0xc6, 0x25, 0xac, 0x61, 0x03, 0xb9, 0x93, 0x5d, 0xf0, 0xa8, 0xfc,
	0xf2, 0x55, 0xab, 0xf0, 0xe7, 0xab, 0x96, 0x66, 0x1c, 0x02, 0x38, 0x7c, 0x4e, 0x42, 0xde, 0x8f,
	0x09, 0xe2, 0x44, 0x4d, 0x18, 0x91, 0x5d, 0x61, 0x60, 0x4a, 0x5b, 0xb5, 0xbd, 0x26, 0x7d, 0xc6,
	0x8f, 0x40, 0x97, 0x74, 0x53, 0xa2, 0x84, 0xee, 0xe6, 0x83, 0xe8, 0x5d, 0xa8, 0x76, 0x35, 0xf3,
	0xef, 0x9d, 0x62, 0xc6, 0x1e, 0xb8, 0x9d, 0x12, 0x73, 0x14, 0x2b, 0xea, 0x6b, 0x18, 0x8d, 0x07,
	0x60, 0x5b, 0x62, 0x86, 0x79, 0xe1, 0x5e, 0x87, 0x18, 0x81, 0x2d, 0x89, 0x98, 0x88, 0x4e, 0xff,
	0xf0, 0x2a, 0x36, 0x1e, 0x83, 0x5a, 0xaa, 0xaa, 0xcc, 0xe9, 0xff, 0x20, 0x52, 0x17, 0xea, 0x8b,
	0xe6, 0xfa, 0x70, 0x9e, 0xdd, 0x10, 0x6c, 0x5e, 0x9e, 0x57, 0x70, 0x07, 0x14, 0x87, 0x87, 0x13,
	0xe7, 0x69, 0xbd, 0xd0, 0xa8, 0x9c, 0x9c, 0xb6, 0x8b, 0xc3, 0x20, 0xe2, 0x2b, 0x91, 0xf6, 0xbe,
	0x3d, 0xec, 0x3a, 0xc3, 0x41, 0x5d, 0x6b, 0x54, 0x4f, 0x4e, 0xdb, 0xa5, 0xb4, 0x2c, 0xb0, 0x38,
	0x99, 0x3a, 0x5d, 0x5b, 0x9c, 0xac, 0xa5, 0x27, 0x32, 0x11, 0x04, 0x4b, 0xa6, 0xf1, 0x60, 0x38,
	0xa8, 0xdf, 0xca, 0x98, 0xc4, 0xa0, 0xd9, 0x8d, 0x40, 0xfd, 0xea, 0xe7, 0x02, 0xee, 0x82, 0xdb,
	0xe3, 0x91, 0xe3, 0x3e, 0x19, 0x1f, 0x3c, 0x75, 0x1d, 0xbb, 0x3b, 0x9e, 0x8e, 0x86, 0x76, 0xbd,
	0xd0, 0xf8, 0xe8, 0xe4, 0xb4, 0xbd, 0x3d, 0x9e, 0xf3, 0x27, 0xa1, 0xbf, 0x72, 0x62, 0x14, 0x26,
	0x73, 0x12, 0xc3, 0x07, 0x60, 0x67, 0xf4, 0xfd, 0xc1, 0x81, 0x6b, 0xef, 0x3f, 0xfe, 0xce, 0x99,
	0x5e, 0xb8, 0x6b, 0x8d, 0x3b, 0x27, 0xa7, 0x6d, 0x38, 0x5a, 0xfa, 0xbe, 0x4d, 0x17, 0x47, 0x3c,
	0x51, 0x88, 0xde, 0xf4, 0xf5, 0x59, 0x53, 0x7b, 0x73, 0xd6, 0xd4, 0xfe, 0x38, 0x6b, 0x6a, 0x2f,
	0xce, 0x9b, 0x85, 0x37, 0xe7, 0xcd, 0xc2, 0x6f, 0xe7, 0xcd, 0xc2, 0x4f, 0x5f, 0x2f, 0x28, 0x3f,
	0x5a, 0xce, 0x4c, 0x8f, 0x05, 0x56, 0x36, 0xd0, 0xd9, 0x7c, 0x4e, 0x3d, 0x8a, 0x7c, 0x6b, 0xc1,
	0xee, 0xab, 0xff, 0x81, 0x5f, 0xde, 0xf9, 0x23, 0x10, 0x5f, 0xc5, 0x64, 0xb6, 0x21, 0x7b, 0xfc,
	0xab, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x5a, 0xfe, 0xc0, 0x93, 0x35, 0x08, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IssuePrice.Equal(&that1.IssuePrice) {
		return false
	}
	return true
}
func (m *Auction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Auction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Claimed {
		i--
		if m.Claimed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.EndAuctionAt != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndAuctionAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndAuctionAt):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintAuction(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x72
	}
	if m.EndedAt != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndedAt):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintAuction(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x6a
	}
	if m.LastBid != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastBid, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastBid):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintAuction(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x62
	}
	if m.LastBidAmount != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.LastBidAmount))
		i--
		dAtA[i] = 0x58
	}
	if m.State != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x50
	}
	if m.TickSize != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.TickSize))
		i--
		dAtA[i] = 0x48
	}
	if m.InstantSalePrice != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.InstantSalePrice))
		i--
		dAtA[i] = 0x40
	}
	if m.PriceFloor != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.PriceFloor))
		i--
		dAtA[i] = 0x38
	}
	if len(m.BidDenom) > 0 {
		i -= len(m.BidDenom)
		copy(dAtA[i:], m.BidDenom)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.BidDenom)))
		i--
		dAtA[i] = 0x32
	}
	if m.Duration != nil {
		n4, err4 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Duration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Duration):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintAuction(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x2a
	}
	if m.PrizeType != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.PrizeType))
		i--
		dAtA[i] = 0x20
	}
	if m.NftId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.NftId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Bid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x18
	}
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Bidder) > 0 {
		i -= len(m.Bidder)
		copy(dAtA[i:], m.Bidder)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Bidder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BidderMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidderMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BidderMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastBidCancelled {
		i--
		if m.LastBidCancelled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.LastBidTimestamp != nil {
		n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastBidTimestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastBidTimestamp):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintAuction(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x22
	}
	if m.LastBid != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.LastBid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LastAuctionId) > 0 {
		i -= len(m.LastAuctionId)
		copy(dAtA[i:], m.LastAuctionId)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.LastAuctionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bidder) > 0 {
		i -= len(m.Bidder)
		copy(dAtA[i:], m.Bidder)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Bidder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.IssuePrice.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventCreateAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCreateAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCreateAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetAuctionAuthority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetAuctionAuthority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetAuctionAuthority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0x12
	}
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventStartAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStartAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventStartAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventEndAuction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEndAuction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEndAuction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventPlaceBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPlaceBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPlaceBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Bidder) > 0 {
		i -= len(m.Bidder)
		copy(dAtA[i:], m.Bidder)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Bidder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCancelBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCancelBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCancelBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Bidder) > 0 {
		i -= len(m.Bidder)
		copy(dAtA[i:], m.Bidder)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Bidder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventClaimBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventClaimBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventClaimBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Bidder) > 0 {
		i -= len(m.Bidder)
		copy(dAtA[i:], m.Bidder)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Bidder)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuction(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Auction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAuction(uint64(m.Id))
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.NftId != 0 {
		n += 1 + sovAuction(uint64(m.NftId))
	}
	if m.PrizeType != 0 {
		n += 1 + sovAuction(uint64(m.PrizeType))
	}
	if m.Duration != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Duration)
		n += 1 + l + sovAuction(uint64(l))
	}
	l = len(m.BidDenom)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.PriceFloor != 0 {
		n += 1 + sovAuction(uint64(m.PriceFloor))
	}
	if m.InstantSalePrice != 0 {
		n += 1 + sovAuction(uint64(m.InstantSalePrice))
	}
	if m.TickSize != 0 {
		n += 1 + sovAuction(uint64(m.TickSize))
	}
	if m.State != 0 {
		n += 1 + sovAuction(uint64(m.State))
	}
	if m.LastBidAmount != 0 {
		n += 1 + sovAuction(uint64(m.LastBidAmount))
	}
	if m.LastBid != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastBid)
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.EndedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndedAt)
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.EndAuctionAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndAuctionAt)
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.Claimed {
		n += 2
	}
	return n
}

func (m *Bid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bidder)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	if m.Amount != 0 {
		n += 1 + sovAuction(uint64(m.Amount))
	}
	return n
}

func (m *BidderMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bidder)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	l = len(m.LastAuctionId)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.LastBid != 0 {
		n += 1 + sovAuction(uint64(m.LastBid))
	}
	if m.LastBidTimestamp != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastBidTimestamp)
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.LastBidCancelled {
		n += 2
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IssuePrice.Size()
	n += 1 + l + sovAuction(uint64(l))
	return n
}

func (m *EventCreateAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	return n
}

func (m *EventSetAuctionAuthority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *EventStartAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	return n
}

func (m *EventEndAuction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	return n
}

func (m *EventPlaceBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bidder)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	return n
}

func (m *EventCancelBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bidder)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	return n
}

func (m *EventClaimBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bidder)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	return n
}

func sovAuction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuction(x uint64) (n int) {
	return sovAuction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Auction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Auction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Auction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			m.NftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NftId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeType", wireType)
			}
			m.PrizeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrizeType |= AuctionPrizeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Duration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BidDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceFloor", wireType)
			}
			m.PriceFloor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceFloor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstantSalePrice", wireType)
			}
			m.InstantSalePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstantSalePrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickSize", wireType)
			}
			m.TickSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AuctionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBidAmount", wireType)
			}
			m.LastBidAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBidAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastBid == nil {
				m.LastBid = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastBid, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAuctionAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndAuctionAt == nil {
				m.EndAuctionAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndAuctionAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Claimed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bidder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidderMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidderMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidderMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bidder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAuctionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastAuctionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBid", wireType)
			}
			m.LastBid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBidTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastBidTimestamp == nil {
				m.LastBidTimestamp = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastBidTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBidCancelled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastBidCancelled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuePrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IssuePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCreateAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCreateAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCreateAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetAuctionAuthority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetAuctionAuthority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetAuctionAuthority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStartAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStartAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStartAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEndAuction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEndAuction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEndAuction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPlaceBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPlaceBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPlaceBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bidder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCancelBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCancelBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCancelBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bidder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventClaimBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventClaimBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventClaimBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bidder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuction = fmt.Errorf("proto: unexpected end of group")
)
